
#pragma once

/*
struct elementWithNodalData {
  int elementID;
  int elementTagNumber;
  std::vector<int> elementTags;
  std::vector<std::vector<double>> nodeCoordinates;
  
};
*/

#include <iostream>
#include <vector>


struct EXOIIGlobalVariables {
  
  std::string directory;
  std::string title = "untitled_mesh";
  int nodes;
  int dimensions;
  int elements;
  int elementBlocks;
  int nodeSets;
  int sideSets;
  int databaseVersionNumber = 634;
  int APIVersionNumber;
  
  int threads = 1;
  
  //Why would you even want 4?
  int IOWordSize = 8;
  int CharacterStringLength = 32;
  int CharacterLineLength = 80;
  
  //Tag groups to generate nodesets and sidesets from
  //NOTE: Data in this range MUST BE nodes or physical lines
  //That is type 15 with 1 node or type 1 with 2 nodes.
  //ALL OTHER DATA IN THIS RANGE WILL BE IGNORED.
  
  //Minimum to Minimum + Size = 
  int includedTagMinimum = 10;
  int includedTagMaximum = 100;
};


struct meshStringData {
  int elementNumber;
  std::vector<std::string> elements;
  int nodeNumber;
  std::vector<std::string> nodes;
};




//Pseudo exodus data. It's about 60% exodus 40% msh at this point.
struct exodusNodeInputData {
  
  //All node coordinates in order from 1 to n.
  //0 - x, 1 - y, 2 - z. Exodus supports 1 - 3 dimensions but this program is n dimensional.
  std::vector<std::vector<double>> nodeCoordinates;
  
  //The first level is all nodes in the problem.
  //The second level contains any nodesets that a node belongs to.
  //Nodesets are numerical. All nodes belong to the nodeset -1
  std::vector<std::vector<int>> nodeSets;
  
  //Nodeset names are generated by taking the input file
  std::vector<std::string> nodeSetNames;
};



//A container for a generic exoII element referenced by exodusMeshInputData.
//At this point it's like 85% exoII and 15% msh but exodus can ignore the msh part.

struct exoIIElement {
  
  //For converting from coordinates to a coordinate array used by exodusII
  //Read all the x coordinates, followed by all y, and then all x.
  std::vector<std::vector<double>> nodalCoordinates;
  std::vector<int> nodeIDs;
  
  //The only relics of msh
  int elementType;
  int elementTag;
  
  
};



struct NumericalMeshData {
  
  //Level 1 is nodes and elements in input files
  //Level 2 is data about nodes and elements.
  std::vector<std::vector<double>> nodes;
  std::vector<exoIIElement> elements;
  
  
  //std::vector<exoIIElement> sidesetElements;
 // std::vector<exoIIElement> nodesetElements;
  
  
};

struct exoIINodesetComponent {
  
  int nodeID;
  int nodesetID;
};



//Moses generates one element block for every exoII Element Type. There can be up to 6 exoII element blocks.
struct exoIIElementBlock {
  
  //These determine what the element's type is and are assigned to match the number of nodes on the element
  //In order and respectively these values are as such:
  // 2/3/4/Truss, 4/8/9/Quad, 4/11/Tetra, 5/13/Pyramid, 6/15/Prism, 8/20/Hex
  //As a result, blockID is also used for setting the "nodes per element" parameter
  //int blockID;
  std::string elementType;
  int nodesPerElement;  
  
  std::vector<exoIIElement> elements;

  
};


struct exoIISideSetComponent {
  int elementID;
  int elementSide;
  
  int sideSetID;
};

//One sideset made up of many components
struct exoIISideSet {
  std::vector<exoIISideSetComponent> components;
};

//One metastructure to rule them all.
//The exoIIInputData structure contains everything needed to create an exoII file.
//If additionally functionallity is needed in the exoII file, such as distribution factors
//one should place it here
struct exoIIInputData {
  
  std::vector<exoIISideSet> sideSets;
  std::vector<std::vector<int>> nodeSets;
  std::vector<exoIIElementBlock> elementBlocks;
  
  std::vector<std::vector<double>> flippedNodes;
  
  
  
  EXOIIGlobalVariables globalVariables;
  
};


